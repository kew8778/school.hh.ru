/*

Условие задачи

Ограничение времени, с	1
Ограничение памяти для Python, МБ	64
Ограничение памяти для Java, МБ	128
Ограничение памяти для JavaScript, МБ	64
Общее число попыток отправки	15

Вы очнулись в определённой ячейке (x1,y1) лабиринта, с его картой в руке. Карта показывает, что лабиринт представляет собой окружённый сплошной стеной прямоугольник высотой N и шириной M, состоящий из ячеек, каждая ячейка самого лабиринта – это проход 0 или стена 1. Перемещаться по лабиринту можно по горизонтали (меняя координату x) либо по вертикали (меняя координату y) на одну ячейку, перемещаться по диагонали (меняя за один шаг обе координаты) нельзя.

На карте отмечен выход, и он находится в ячейке с координатами (x2,y2).

Ваша задача – найти длину кратчайшего пути из ячейки пробуждения в ячейку выхода. В случае, если такого пути нет – нужно вывести 0


Входные данные (поступают в стандартный поток ввода)
Первая строка - целые числа N и M через пробел (2≤N≤500, 2≤M≤500)

Вторая строка – целые числа x1 и y1 через пробел (0≤x1≤499, 0≤y1≤499) – координаты точки пробуждения

Третья строка – целые числа x2 и y2 через пробел (0≤x2≤499, 0≤y2≤499) – координаты точки выхода

Далее N строк, на каждой из которых M чисел 0 или 1 через пробел

Нумерации осей в передаваемых значениях следуют слева направо для X и с первой полученной строки до последней для Y.
По координатам (x1,y1) и (x2,y2) всегда будут проходы. Координаты точки входа и выхода не совпадают.

Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются


Выходные данные (ожидаются в стандартном потоке вывода)
Одно целое число, длина кратчайшего пути из точки (x1,y1) в точку (x2,y2), или 0,
если из одной точки нельзя попасть в другую

*/


const readline = require('readline').createInterface(process.stdin, process.stdout);

let numStr = 1; // номер строки в событии line

// размеры лабиринта
let n; // высота
let m; // ширина

const lab = []; // матрица лабиринта

let start; // стартовая точка [x, y]
let end; // выход - конечная точка [x, y]

readline.on('line', (line) => {
  if (numStr == 1) {
    let nm = line.split(' ');
    n = nm[0];
    m = nm[1];
    numStr++;
  } else if (numStr == 2) {
    start = line.split(' ');
    numStr++;
  } else if (numStr == 3) {
    end = line.split(' ');
    numStr++;
  } else {
    lab.push(line.split(' '));
  }
    
}).on('close', () => {

  lab[ +start[1] ][ +start[0] ] = 0;
  let varArr = [ [ +start[0], +start[1] ] ]; // временный массив
  let arr = []; // вспомогательный

  function mark(square, num) {
  let x = square[0];
  let y = square[1];

  // отмечаем снизу, добавляем в массив
  if (y < n - 1) {
    if (lab[y + 1][x] === '0') {
      lab[y + 1][x] = num;
      arr.push([x, y + 1]);
    }
  }

  // отмечаем вверху, добавляем в массив
  if (y > 0) {
    if (lab[y - 1][x] === '0') {
      lab[y - 1][x] = num;
      arr.push([x, y - 1]);
    }
  }

  // отмечаем справа, добавляем в массив
  if (x < m - 1) {
    if (lab[y][x + 1] === '0') {
      lab[y][x + 1] = num;
      arr.push([x + 1, y]);
    }
  }

  // отмечаем слева, добавляем в массив
  if (x > 0) {
    if (lab[y][x - 1] === '0') {
      lab[y][x - 1] = num;
      arr.push([x - 1, y]);
    }
  }
}
  
  let num = 0; // для меток
  while (varArr.length > 0) {
    num++;
    let i2 = varArr.length;
  
    for (let i = 0; i < i2; i++) {
      mark(varArr[i], num);
    }
  
    varArr = arr;
    arr = [];
  }

  console.log(lab[ +end[1] ][ +end[0] ]);
  
  process.exit(0);
});
