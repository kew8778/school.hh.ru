/*

Условие задачи

Ограничение времени, с	1
Ограничение памяти, МБ	64
Общее число попыток отправки	15

Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.

Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время или раньше.

В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.

Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки


Входные данные (поступают в стандартный поток ввода)
Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)

Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)

Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются


Выходные данные (ожидаются в стандартном потоке вывода)
Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.

*/


const readline = require('readline').createInterface(process.stdin, process.stdout);

let numStr = 0; // номер строки
let n; // кол-во мест
let m; // кол-во выделенного времени

const c = Array(10001).fill(0); // кол-во мест с ind печенек

readline.on('line', (line) => {
  if (numStr == 0) {
    let nm = line.split(' ');
    n = nm[0];
    m = nm[1];
    numStr++;
  } else {
    c[line]++;
  }
    
}).on('close', () => {
  let kMax = 10001; // верхняя граница поиска
  let kMin = 0; // нижняя
  let k = median(); // печень в час (скорость жора)
  let t = time(k); // необходимое время на жор при заданном k
  let tn; // искомое значение 

  while (kMax - kMin != 1) {
    if (t <= m) {
      tn = k;

      kMax = k;
      k -= median();
    }

    if (t > m) {
      kMin = k;
      k += median();
    }

    t = time(k);
  }

  if (t <= m) {
    tn = k;
  }

  if (tn && c[0] != n) {
    console.log(tn);
  } else {
    console.log(0);
  }

  function time(k) {
    let t = 0;

    for (let i = 1; i <= 10000; i++) {
      t += Math.ceil(i / k) * c[i];
    }

    return t;
  }

  function median() {
    return Math.ceil( (kMax - kMin) / 2 );
  }
  
  process.exit(0);
});
